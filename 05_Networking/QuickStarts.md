# Quick Starts

## Exposing Ports to Your Host System
You are being asked to run an Nginx container listening on port 80, but that port is not available on the host. Complete the following tasks:

1. Using the appropriate Docker CE commands, download the latest 'nginx' webserver image from Docker Hub.

> docker pull nginx:latest

2. Instantiate a container based on the 'nginx' image from the previous step. This container should have the following characteristics:

  * when started, the container should run in 'detached' mode

  * name the container 'nginxtest'

  * use the appropriate option to allow Docker to map all container service ports to random host ports over 32768

  * the container is based on the 'nginx' image from step one

> docker run -d --name nginxtest -P nginx

3. Verify the container is running and find the host port that is mapped to the web server's port 80

> docker ps 

CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                   NAMES
6b272fd5b216        nginx                   "nginx -g 'daemon of…"   5 seconds ago       Up 4 seconds        0.0.0.0:32768->80/tcp   nginxtest
6d5339175bc7        spacebones:thewebsite   "/usr/sbin/apachectl…"   2 hours ago         Up 2 hours          0.0.0.0:80->80/tcp      testweb


4. Using any tool you wish, verify that the default site page is served (NOTE: use the cloud server's PRIVATE ADDRESS for your testing)


curl localhost:32768
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>

## Create a Docker Service on Your Swarm and Expose Service Ports to Each Host

1. Using the appropriate command, pull the latest 'httpd' image from Docker Hub.

 >  docker pull httpd

2. Create a service on your cluster that meets the following requirements:

  * name the service 'testweb'

  * map the service web port of 80 to the underlying service hosts port of 80

  * base it on the 'httpd' service above

  * initialize the service with three replicas

docker service create -d --name testweb -p 80:80 --replicas 3 httpd

3. Verify the service is running

> docker service ls
ID                  NAME                MODE                REPLICAS            IMAGE               PORTS
ez4vlwsvl115        testweb             replicated          3/3                 httpd:latest        *:80->80/tcp

4. List the all nodes and verify replicas are running on all three

> docker service ps testweb
ID                  NAME                IMAGE               NODE                                    DESIRED STATE       CURRENT STATE            ERROR               PORTS
i908k1p4x5wu        testweb.1           httpd:latest        craig-nicholsoneswlb4.mylabserver.com   Running             Running 23 seconds ago                       
ob6uxaq520gx        testweb.2           httpd:latest        craig-nicholsoneswlb6.mylabserver.com   Running             Running 23 seconds ago                       
5zhr83g3ro3z        testweb.3           httpd:latest        craig-nicholsoneswlb5.mylabserver.com   Running             Running 15 seconds ago                       

5. Using whatever method you choose, check that the default site in the service is being served when you check port 80 on all three nodes

> curl craig-nicholsoneswlb4.mylabserver.com
<html><body><h1>It works!</h1></body></html>

> curl craig-nicholsoneswlb5.mylabserver.com
<html><body><h1>It works!</h1></body></html>

> curl craig-nicholsoneswlb6.mylabserver.com
<html><body><h1>It works!</h1></body></html>

## Utilize External DNS With Your Containers

Your company's DNS servers are having issues but you need to launch a web container that can resolve outside named resources. Your tasks are as follows:

1. Using the Docker base image for Ubuntu, create a container with the following characteristics:

* Interactive
* Attached to Terminal
* Using Google Public DNS
* Named 'mycontainer1'

> docker pull ubuntu
> cat /etc/resolv.conf
Generated by NetworkManager
search mylabserver.com
nameserver 172.31.0.2
> docker run -it --name mycontainer1 --dns=8.8.8.8 --dns=8.8.4.4 ubuntu
cat /etc/resolv.conf 
search mylabserver.com
nameserver 8.8.8.8
nameserver 8.8.4.4

2. Exit the container from Step #1. Using the Docker base image for Ubuntu, create a container with the following characteristics:

* Interactive
* Attached to Terminal
* Using Google Public DNS
* Using Domain Search "mydomain.local"
* Named 'mycontainer2'

> docker run -it --name mycontainer2 --dns=8.8.8.8 --dns=8.8.4.4  --dns-search="mydomain.local" ubuntu
root@cbfb803f8c6d:/# cat /etc/resolv.conf
search mydomain.local
nameserver 8.8.8.8
nameserver 8.8.4.4

3. Exit the container from Step #2. List all the containers. List all characteristics inspected from 'mycontainer2' and then remove and verify removal of all containers.

> docker container inspect mycontainer2
[
    {
        "Id": "cbfb803f8c6d37989298efd5023fbd0c5f694918d33c8e059fb21fbc5e972ce9",
        "Created": "2018-08-04T23:16:16.242759815Z",
        "Path": "/bin/bash",
        "Args": [],
        "State": {
            "Status": "exited",
            "Running": false,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 0,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2018-08-04T23:16:16.683151774Z",
            "FinishedAt": "2018-08-04T23:17:00.325075843Z"
        },
        "Image": "sha256:735f80812f90aca43213934fd321a75ef20b2e30948dbbdd2c240e8abaab8a28",
        "ResolvConfPath": "/var/lib/docker/containers/cbfb803f8c6d37989298efd5023fbd0c5f694918d33c8e059fb21fbc5e972ce9/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/cbfb803f8c6d37989298efd5023fbd0c5f694918d33c8e059fb21fbc5e972ce9/hostname",
        "HostsPath": "/var/lib/docker/containers/cbfb803f8c6d37989298efd5023fbd0c5f694918d33c8e059fb21fbc5e972ce9/hosts",
        "LogPath": "/var/lib/docker/containers/cbfb803f8c6d37989298efd5023fbd0c5f694918d33c8e059fb21fbc5e972ce9/cbfb803f8c6d37989298efd5023fbd0c5f694918d33c8e059fb21fbc5e972ce9-json.log",
        "Name": "/mycontainer2",
        "RestartCount": 0,
        "Driver": "devicemapper",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "Dns": [
                "8.8.8.8",
                "8.8.4.4"
            ],
            "DnsOptions": [],
            "DnsSearch": [
                "mydomain.local"
            ],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "shareable",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DiskQuota": 0,
            "KernelMemory": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": 0,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/asound",
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "DeviceId": "42",
                "DeviceName": "docker-202:1-8827929-ff72d0e97b449fb7fa07ad8b37e5da0066d3d6bd42518b47af82c582725e74f9",
                "DeviceSize": "10737418240"
            },
            "Name": "devicemapper"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "cbfb803f8c6d",
            "Domainname": "",
            "User": "",
            "AttachStdin": true,
            "AttachStdout": true,
            "AttachStderr": true,
            "Tty": true,
            "OpenStdin": true,
            "StdinOnce": true,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/bash"
            ],
            "ArgsEscaped": true,
            "Image": "ubuntu",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {}
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "a6210a28187ef509661f6c932e9d3e93ab1e144290093d0cb552ea1f4005708b",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/a6210a28187e",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "",
            "Gateway": "",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "",
            "IPPrefixLen": 0,
            "IPv6Gateway": "",
            "MacAddress": "",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "2a6f0b82e37d48ba4c68cef88a5145f21e51840438f4a488e1d6c7de472ca42b",
                    "EndpointID": "",
                    "Gateway": "",
                    "IPAddress": "",
                    "IPPrefixLen": 0,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "",
                    "DriverOpts": null
                }
            }
        }
    }
]

> docker ps -a

> docker rm $(docker ps -a)

> docker ps -a

> docker ps

## Create a New Bridge Network and Assign a Container To It

Your development team would like a separate container test network on their Docker host to assign and test certain workloads. You have been asked to create one and verify it works as expected. Your tasks are as follows:

1. Display existing Docker networks and names on your host

> docker network ls

2. Create a new network as follows:

* use the 'bridge' driver
* assigns IP addresses in the '192.168.1.0/24' network range
* uses a gateway address of 192.168.1.250
* called 'dev_bridge'

> docker network create --driver=bridge --subnet=192.168.1.0/24 --gateway=192.168.1.250 dev_bridge

docker network inspect dev_bridge
[
    {
        "Name": "dev_bridge",
        "Id": "07d1a74ec45cc05f9e8dafb298eb49b51754fefb1663fa62f4fc24a84d26fdd7",
        "Created": "2018-08-04T23:23:37.114140044Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "192.168.1.0/24",
                    "Gateway": "192.168.1.250"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {},
        "Options": {},
        "Labels": {}
    }
]

3. Display all Docker networks on the host

> docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
2a6f0b82e37d        bridge              bridge              local
07d1a74ec45c        dev_bridge          bridge              local
62cdcf57695b        docker_gwbridge     bridge              local
a7aa25b5c5e8        host                host                local
dh260ff9qpr9        ingress             overlay             swarm
fedcd5372b53        none                null                local

4. Pull the 'httpd' image and install locally

> docker pull httpd

5. Create a container called 'testweb' based on the image in the previous step as follows:

* assigned to new 'dev_bridge' network on start

docker run -d --name testweb -p 80:80 --network=dev_bridge httpd
docker run -d --name testweb --network=dev_bridge httpd

6. Using the appropriately formatted Docker command output, display the container's IP(s) to include the new network

> docker container inspect --format="{{.NetworkSettings.Networks.dev_bridge.IPAddress}}" testweb